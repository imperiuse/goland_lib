package repository

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/pkg/errors"

	_ "github.com/jackc/pgx/v4/stdlib"

	"github.com/Masterminds/squirrel"
	"github.com/imperiuse/golib/reflect/orm"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"go.uber.org/zap"
)

const (
	PostgresUser     = "test"
	PostgresPassword = "test"
	PostgresDB       = "test"
	PostgresHost     = "localhost"
	PostgresPort     = "5433"
)

type RepositoryTestSuit struct {
	suite.Suite
	ctx        context.Context
	ctxCancel  context.CancelFunc
	logger     *zap.Logger
	repos      Repositories
	db         *sqlx.DB
	goodMockDb SqlxDBConnectorI
	badMockDb  SqlxDBConnectorI
}

// DTO
type (
	Integer = int64

	NotDTO struct{}

	BaseDTO struct {
		ID        Integer   `db:"id"          orm_use_in:"select"`
		CreatedAt time.Time `db:"created_at"  orm_use_in:"select"`
		UpdatedAt time.Time `db:"updated_at"  orm_use_in:"select,update"`
	}

	User struct {
		BaseDTO
		Name     string  `db:"name"     orm_use_in:"select,create,update"`
		Email    string  `db:"email"    orm_use_in:"select,create,update"`
		Password string  `db:"password" orm_use_in:"select,create,update"`
		RoleID   Integer `db:"role_id" orm_use_in:"select,create,update"`
		_        bool    `orm_table_name:"Users" orm_alias:"u"`
	}

	Role struct {
		BaseDTO
		Name   string `db:"name"       orm_use_in:"select,create,update"`
		Rights int    `db:"rights"     orm_use_in:"select,create,update"`
		_      bool   `orm_table_name:"Roles" orm_alias:"r"`
	}

	UsersRole struct {
		User `db:"u" orm_alias:"u"`
		Role `db:"r" orm_alias:"r"`
		_    bool `orm_join:" ON u.role_id = r.id "`
	}
)

func (b *BaseDTO) Identity() ID {
	return b.ID
}

var DSL = map[string]string{
	"Roles": `CREATE TABLE IF NOT EXISTS Roles
(
id           INTEGER     PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
created_at   TIMESTAMP   NOT NULL DEFAULT NOW(),
updated_at   TIMESTAMP   NOT NULL DEFAULT NOW(),
name         TEXT        NOT NULL,
rights      INTEGER     NOT NULL
);`,
	"Users": `CREATE TABLE IF NOT EXISTS Users
(
id           INTEGER     PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
created_at   TIMESTAMP   NOT NULL DEFAULT NOW(),
updated_at   TIMESTAMP   NOT NULL DEFAULT NOW(),
name         TEXT        NOT NULL,
email        TEXT        NOT NULL,
password     TEXT        NOT NULL,
role_id      INTEGER     NOT NULL,
CONSTRAINT fkey__r FOREIGN KEY (role_id) REFERENCES roles (id) MATCH SIMPLE	ON UPDATE NO ACTION ON DELETE CASCADE
);`,
}

var DTOs = []interface{}{&User{}, &Role{}}

// The SetupSuite method will be run by testify once, at the very
// start of the testing suite, before any tests are run.
func (suite *RepositoryTestSuit) SetupSuite() {
	suite.ctx, suite.ctxCancel = context.WithCancel(context.Background())
	suite.logger = zap.NewNop()

	suite.badMockDb = badMockDBConn
	suite.goodMockDb = goodMockDBConn

	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s",
		PostgresUser,
		PostgresPassword,
		PostgresHost,
		PostgresPort,
		PostgresDB,
	)

	db, err := sqlx.Connect("pgx", dsn)
	assert.Nil(suite.T(), err)
	assert.NotNil(suite.T(), db)

	suite.db = db

	orm.InitMetaTagInfoCache(DTOs...)
	orm.InitMetaTagInfoCache(&BaseDTO{}, &UsersRole{})

	tables := []string{}
	// create table
	for _, obj := range DTOs {
		table := orm.GetTableName(obj)
		assert.NotEqual(suite.T(), "", table)
		tables = append(tables, table)

		_, err = db.ExecContext(suite.ctx, DSL[table])
		assert.Nil(suite.T(), err)
	}

	// Refresh DB
	for _, table := range tables {
		_, err = db.ExecContext(suite.ctx, fmt.Sprintf("TRUNCATE TABLE %s RESTART IDENTITY CASCADE;", table))
		assert.Nil(suite.T(), err)
	}

	suite.repos = NewSqlxMapRepo(suite.logger, db, tables, nil)
	assert.NotNil(suite.T(), suite.repos)
}

// The TearDownSuite method will be run by testify once, at the very
// end of the testing suite, after all tests have been run.
func (suite *RepositoryTestSuit) TearDownSuite() {
	for _, obj := range DTOs {
		id, err := suite.repos.AutoRepo(obj).Delete(suite.ctx, 1)
		assert.Nil(suite.T(), err)
		assert.Equal(suite.T(), int64(0), id)
	}

	assert.Nil(suite.T(), suite.db.Close())
}

// The SetupTest method will be run before every test in the suite.
func (suite *RepositoryTestSuit) SetupTest() {
	suite.ctx, suite.ctxCancel = context.WithCancel(context.Background())
}

// The TearDownTest method will be run after every test in the suite.
func (suite *RepositoryTestSuit) TearDownTest() {
}

// In order for 'go test' to run this suite, we need to create
// a normal test function and pass our suite to suite.Run
func TestSuite(t *testing.T) {
	initTables() // prevent errors when run first containers in github CI
	suite.Run(t, new(RepositoryTestSuit))
}

func initTables() {
	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s",
		PostgresUser,
		PostgresPassword,
		PostgresHost,
		PostgresPort,
		PostgresDB,
	)

	db, _ := sqlx.Connect("pgx", dsn)

	tables := []string{}
	// create table
	for _, obj := range DTOs {
		table := orm.GetTableName(obj)
		tables = append(tables, table)

		_, _ = db.ExecContext(context.Background(), DSL[table])
	}

	// Refresh DB
	for _, table := range tables {
		_, _ = db.ExecContext(context.Background(), fmt.Sprintf("TRUNCATE TABLE %s RESTART IDENTITY CASCADE;", table))
	}

}

func (suite *RepositoryTestSuit) Test_Repo_AutoRepo_SqlxDBConnectorI() {
	t := suite.T()

	for _, obj := range DTOs {
		assert.NotNil(t, suite.repos.AutoRepo(obj).SqlxDBConnectorI())
		assert.Equal(t, suite.db, suite.repos.AutoRepo(obj).SqlxDBConnectorI())
		assert.NotEqual(t, suite.repos.AutoRepo(obj), suite.repos.Repo("_UNKNOWN_"))
		assert.Equal(t, emptyRepo, suite.repos.Repo("_UNKNOWN_"))
		assert.Equal(t, emptyRepo, suite.repos.Repo("_UNKNOWN_2"))
		assert.Equal(t, emptyRepo, suite.repos.AutoRepo(&BaseDTO{}))
		assert.Equal(t, emptyRepo, suite.repos.AutoRepo(&NotDTO{}))
	}

	assert.Equal(t, suite.repos.Repo(orm.GetTableName(&User{})), suite.repos.AutoRepo(User{}))
	assert.NotNil(t, suite.repos.Repo(orm.GetTableName(&User{})))
	assert.Equal(t, suite.repos.Repo(orm.GetTableName(&Role{})), suite.repos.AutoRepo(Role{}))
	assert.NotNil(t, suite.repos.Repo(orm.GetTableName(&Role{})))
}

func (suite *RepositoryTestSuit) Test_EmptyRepo_NotPanic() {
	t := suite.T()

	r := suite.repos.Repo("_UNKNOWN_")
	assert.NotNil(t, r)
	assert.Equal(t, r, emptyRepo)

	assert.NotNil(t, r.SqlxDBConnectorI())
	assert.NotEqual(t, suite.db, r.SqlxDBConnectorI())

	emptyCon := r.SqlxDBConnectorI()

	assert.Equal(t, FakeStringAns, emptyCon.DriverName())

	assert.Equal(t, FakeStringAns, emptyCon.Rebind(""))

	r1, r2, r3 := emptyCon.BindNamed("", nil)
	assert.Equal(t, FakeStringAns, r1)
	assert.Nil(t, r2)
	assert.Equal(t, ErrEmptyRepo, errors.Cause(r3))

	row, err := emptyCon.QueryxContext(suite.ctx, "select * from users;")
	assert.NotNil(t, row)
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))

	row2, err := emptyCon.QueryContext(suite.ctx, "select * from users;")
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))
	assert.NotNil(t, row2)

	assert.Equal(t, &sqlx.Row{}, emptyCon.QueryRowxContext(suite.ctx, "select * from users;"))

	res, err := emptyCon.ExecContext(suite.ctx, "select * from users;")
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))
	assert.NotNil(t, res)

	stmt, err := emptyCon.PrepareContext(suite.ctx, "select * from users;")
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))
	assert.NotNil(t, stmt)

	tx, err := emptyCon.BeginTxx(suite.ctx, nil)
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))
	assert.NotNil(t, tx)

	// CHECK REPO CRUD

	var role Role
	assert.Equal(t, sql.ErrNoRows, errors.Cause(r.Get(suite.ctx, 1, &role)))

	id, err := r.Create(suite.ctx, &role)
	assert.Equal(t, ErrEmptyRepo, errors.Cause(err))
	assert.Equal(t, int64(0), id)

	cnt, err := r.Update(suite.ctx, 1, &role)
	assert.NotNil(t, err)
	assert.Equal(t, int64(0), cnt)

	cnt, err = r.Delete(suite.ctx, 1)
	assert.NotNil(t, err)
	assert.Equal(t, int64(0), cnt)

	var temp interface{}
	err = r.FindBy(suite.ctx, []Column{"*"}, squirrel.Eq{"id": 1}, &temp)
	assert.NotNil(t, err)

	err = r.FindOneBy(suite.ctx, []Column{"*"}, squirrel.Eq{"id": 1}, &temp)
	assert.NotNil(t, err)

	ucnt, err := r.CountByQuery(suite.ctx, squirrel.Select("*").From("unknown"))
	assert.NotNil(t, err)
	assert.Equal(t, uint64(0), ucnt)

	err = r.FindByWithInnerJoin(suite.ctx, []Column{"*"}, "al as al", "ON al.id = p.id", squirrel.Eq{"id": 1}, &temp)
	assert.NotNil(t, err)

	err = r.FindOneByWithInnerJoin(suite.ctx, []Column{"*"}, "al as al", "ON al.id = p.id", squirrel.Eq{"id": 1}, &temp)
	assert.NotNil(t, err)

	rows1, err := r.GetRowsByQuery(suite.ctx, squirrel.Select("*").From("unknown"))
	assert.NotNil(t, err)
	assert.NotNil(t, rows1)

	id, err = r.Insert(suite.ctx, []Column{"name"}, []interface{}{"test"})
	assert.NotNil(t, err)
	assert.Equal(t, int64(0), id)

	cnt, err = r.UpdateCustom(suite.ctx, map[string]interface{}{}, squirrel.Eq{"id": 1})
	assert.NotNil(t, err)
	assert.Equal(t, int64(0), cnt)
}

func (suite *RepositoryTestSuit) Test_CRUD() {
	t := suite.T()

	const (
		rights       = 10
		role1        = "role1"
		updatedRole1 = "role1_updated"
	)

	var role = Role{
		Name:   role1,
		Rights: rights,
	}

	id, err := suite.repos.AutoRepo(&role).Create(suite.ctx, &role)
	assert.Nil(t, err)
	assert.NotNil(t, id)

	// Alternative way
	id2, err := suite.repos.AutoCreate(suite.ctx, &role)
	assert.Nil(t, err)
	assert.NotNil(t, id2)
	// also you can directly get Repo Role  and exec method Create
	assert.NotNil(t, suite.repos.Repo("Roles"))
	//suite.repos.Repo("Roles").Create(.....)

	var temp Role
	err = suite.repos.AutoRepo(&temp).Get(suite.ctx, id, &temp)
	assert.Nil(t, err)
	assert.Equal(t, role.Name, temp.Name)
	assert.Equal(t, role.Rights, temp.Rights)
	assert.NotNil(t, temp.UpdatedAt)
	assert.NotNil(t, temp.CreatedAt)
	assert.NotNil(t, temp.ID)
	assert.Equal(t, id, temp.ID)

	// Alternative way to get obj from db
	var temp2 = Role{
		BaseDTO: BaseDTO{ID: id.(Integer)},
	}
	err = suite.repos.AutoGet(suite.ctx, &temp2)
	assert.Nil(t, err)
	assert.Equal(t, temp, temp2)

	var temp3 Role
	err = suite.repos.Repo(orm.GetTableName(&temp3)).Get(suite.ctx, id, &temp3)
	assert.Nil(t, err)
	assert.Equal(t, temp, temp3)

	role.Name = updatedRole1
	cnt, err := suite.repos.AutoRepo(&role).Update(suite.ctx, id, &role)
	assert.Nil(t, err)
	assert.Equal(t, int64(1), cnt)
	err = suite.repos.AutoRepo(&temp).Get(suite.ctx, id, &temp)
	assert.Nil(t, err)
	assert.Equal(t, role.Name, temp.Name)

	cnt, err = suite.repos.AutoRepo(&role).Delete(suite.ctx, id)
	assert.Nil(t, err)
	assert.Equal(t, int64(1), cnt)

	err = suite.repos.Repo("Roles").Get(suite.ctx, id2, &temp)
	assert.Nil(t, err)
	assert.NotNil(t, temp.ID)

	temp.Name = ""
	cnt, err = suite.repos.AutoUpdate(suite.ctx, &temp)
	assert.Nil(t, err)
	assert.Equal(t, int64(1), cnt)

	temp2.ID = temp.ID
	assert.Nil(t, suite.repos.AutoGet(suite.ctx, &temp2))
	assert.Equal(t, temp, temp2)

	cnt, err = suite.repos.AutoDelete(suite.ctx, &temp)
	assert.Nil(t, err)
	assert.Equal(t, int64(1), cnt)
}

func (suite *RepositoryTestSuit) Test_Advance_RepoFunc() {
	t := suite.T()
	ctx := suite.ctx

	// Create one role, than create one user, than check Join, Cnt
	var role = Role{
		Name:   "new_test_role",
		Rights: 100,
	}
	roleID, err := suite.repos.AutoCreate(ctx, &role)
	defer func() { _, _ = suite.repos.AutoRepo(&role).Delete(ctx, roleID) }()
	assert.Nil(t, err)
	assert.NotNil(t, roleID)

	const newName = "newTestRole"
	// Check Update Custom
	cnt, err := suite.repos.AutoRepo(&role).UpdateCustom(ctx, map[string]interface{}{"name": newName}, squirrel.Eq{"id": roleID})
	assert.Nil(t, err)
	assert.Equal(t, int64(1), cnt)

	var roles []Role
	assert.Nil(t, suite.repos.AutoRepo(&role).FindBy(ctx, []Column{"rights"}, squirrel.Eq{"id": roleID}, &roles))
	assert.Equal(t, 1, len(roles))
	assert.NotEqual(t, newName, roles[0].Name, "role name must not change, because we have not updated name yet ")

	var roleOne Role
	assert.Nil(t, suite.repos.AutoRepo(&role).FindOneBy(ctx, []Column{"rights"}, squirrel.Eq{"id": roleID}, &roleOne))
	assert.NotEqual(t, newName, roleOne, "role name must not change, because we have not updated name yet ")

	roles = roles[1:]
	assert.Nil(t, suite.repos.AutoRepo(&role).FindBy(ctx, []Column{"name"}, squirrel.Eq{"id": roleID}, &roles))
	assert.Equal(t, 1, len(roles))
	assert.Equal(t, newName, roles[0].Name, "role name must change, because we have  updated name already ")

	var user = User{
		Name:     "testUser",
		Email:    "test@test.ru",
		Password: "123456",
		RoleID:   roleID.(int64),
	}

	userID, err := suite.repos.AutoCreate(ctx, &user)
	defer func() { _, _ = suite.repos.AutoRepo(&user).Delete(ctx, userID) }()
	assert.Nil(t, err)
	assert.NotNil(t, userID)

	cols, joinCond := orm.GetDataForSelect(&UsersRole{})
	nameWithAlias := orm.GetTableNameWithAlias(&user)
	joinCond = orm.GetTableNameWithAlias(&Role{}) + " " + joinCond
	var ur UsersRole
	err = suite.repos.AutoRepo(&user).FindOneByWithInnerJoin(ctx, cols, nameWithAlias, joinCond, squirrel.Eq{"u.id": userID}, &ur)
	assert.Nil(t, err)
	assert.NotNil(t, ur)
	assert.Equal(t, userID, ur.User.ID)
	assert.Equal(t, user.Name, ur.User.Name)
	assert.Equal(t, user.Email, ur.User.Email)
	assert.Equal(t, user.Password, ur.User.Password)
	assert.Equal(t, user.RoleID, ur.Role.ID)
	assert.Equal(t, role.Rights, ur.Role.Rights)

	// Insert one more user with same role

	var role2 = Role{
		Name:   "role2",
		Rights: 50,
	}
	cols, args := orm.GetDataForCreate(role2)
	role2ID, err := suite.repos.AutoRepo(&role2).Insert(ctx, cols, args)
	assert.Nil(t, err)
	assert.NotNil(t, role2ID)
	defer func() { _, _ = suite.repos.AutoRepo(&role).Delete(ctx, role2ID) }()

	{
		cnt, err := suite.repos.AutoRepo(&role2).CountByQuery(ctx, squirrel.Select("count(1)").From(orm.GetTableName(&role2)))
		assert.Nil(t, err)
		assert.Equal(t, uint64(2), cnt)

		_, err = suite.repos.AutoRepo(&role2).CountByQuery(ctx, squirrel.Select("*").From(orm.GetTableName(&role2)))
		assert.NotNil(t, err)

		_, err = suite.repos.AutoRepo(&role2).CountByQuery(ctx, squirrel.Select("*"))
		assert.NotNil(t, err)
	}

	rows, err := suite.repos.AutoRepo(&role2).GetRowsByQuery(ctx, squirrel.Select("*").From(orm.GetTableName(&role2)))
	assert.Nil(t, err)
	assert.NotNil(t, rows)
}

func (suite *RepositoryTestSuit) Test_GetAllPossibleErrors() {
	t := suite.T()
	ctx := suite.ctx

	_, err := suite.repos.AutoRepo(&Role{}).CountByQuery(ctx, squirrel.Select())
	assert.NotNil(t, err)

	_, err = suite.repos.AutoRepo(&Role{}).GetRowsByQuery(ctx, squirrel.Select())
	assert.NotNil(t, err)

	{
		err = suite.repos.AutoRepo(&User{}).FindByWithInnerJoin(ctx, []string{}, "", "", squirrel.Eq{}, nil)
		assert.NotNil(t, err)
	}

	assert.NotNil(t, suite.repos.AutoRepo(&User{}).FindBy(ctx, []string{}, squirrel.Eq{}, nil))

	assert.NotNil(t, suite.repos.AutoRepo(&User{}).FindOneBy(ctx, []string{}, squirrel.Eq{}, nil))

	{
		id, err := suite.repos.AutoRepo(&User{}).Insert(ctx, []string{}, []interface{}{})
		assert.NotNil(t, err)
		assert.Equal(t, int64(0), id)
	}

	{
		id, err := suite.repos.AutoRepo(&User{}).Create(ctx, new(interface{}))
		assert.NotNil(t, err)
		assert.Equal(t, int64(0), id)

		id, err = suite.repos.AutoRepo(&User{}).Create(ctx, nil)
		assert.NotNil(t, err)
		assert.Equal(t, int64(0), id)

		id, err = suite.repos.AutoRepo(&User{}).Create(ctx, &NotDTO{})
		assert.NotNil(t, err)
		assert.Equal(t, int64(0), id)
	}

}

func (suite *RepositoryTestSuit) Test_ConvertFunc() {
	t := suite.T()

	tests := []struct {
		Input  interface{}
		OutInt int64
		OutStr string
	}{
		{
			Input:  0,
			OutInt: 0,
			OutStr: "0",
		},
		{
			Input:  123,
			OutInt: 123,
			OutStr: "123",
		},
		{
			Input:  "123",
			OutInt: 123,
			OutStr: "123",
		},
		{
			Input:  1.23,
			OutInt: 0,
			OutStr: "1.23",
		},
		{
			Input:  nil,
			OutInt: 0,
			OutStr: "0",
		},
	}

	for _, v := range tests {
		assert.Equal(t, v.OutInt, ConvertIDToInt64(v.Input))
		assert.Equal(t, v.OutStr, ConvertIDToString(v.Input))
	}

}
